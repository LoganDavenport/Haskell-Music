module Interval ( fifth, up )where

import qualified Frequency
import qualified Pitch
import qualified Note
import qualified Key
import qualified Data.List

{-- since we bake in the interval of a semitone (in-order generator) to [Pitch.T], we do the same here

[Interval.T]s are a group under addition which act on [Pitch.T]s (and structures built from [Pitch.T]s)

 --}
type T = Int

id :: T
id = 0

{-- the fundamental assumtion of 12 tone equal temperament is that a fifth is just 7 semitones

(equivalently that the semitone generates all tones and the 12 fifths = 7 octaves)



 --}
fifth :: T
fifth = 7

octave :: T
octave = 12

{-- up is the group action of [Interval.T]s on [Pitch.T]s of going up the interval --}
up :: T -> Pitch.T -> Pitch.T
up t p = p + t

{-- down is the group action of [Interval.T]s on [Pitch.T]s of going down the interval --}
down :: T -> Pitch.T -> Pitch.T
down t p = p - t

inverse :: T -> T
inverse = negate

upFromInKey :: Key.Sketch -> T -> Note.T -> Note.T
upFromInKey sketch t n =
        head (Note.ofPitch sketch (Note.pitch n + t))

{-- the only interval which can't be named uniquely is the tritone, which is out of key anyway
 --}
upFrom :: T -> Note.T -> Note.T
upFrom t n = upFromInKey (Key.singletonSketch (Note.tone n)) t n


frequenciesFromFifths :: [(Note.T, Frequency.T)]
frequenciesFromFifths =
    let jumpAFifth (note, frequency) = (upFrom fifth note, frequency * 1.5)
        unshiftedFrequencies = take 12 (iterate jumpAFifth (Note.ofString "F3", Frequency.f3))
        setOctave n (note, frequency) =
                (note { Note.octave = n }, frequency * (2^^(n - Note.octave note)))
    in
    Data.List.sortOn fst (map (setOctave 4) unshiftedFrequencies)


frequenciesFromSemitones :: [(Note.T, Frequency.T)]
frequenciesFromSemitones =
    let jumpASemitone (note, frequency) =
            (upFromInKey Key.sharpSketch 1 note, frequency * Frequency.halfStep)
    in
    take 12 (iterate jumpASemitone (Note.ofString "C4", Frequency.c4))

{-- notes get sharper (relative to equal temperament) as they are generated by fifths 
this is due to the fact that (3/2)^12 = ~129.746 > 128 (= 7 octaves) 
and is probably not very interesting, though the difference is quite a bit at +/-~10 cents
difference if chosing the right note to start with perfect fifths from

the fact still stands though that the interval of the fifth (= -fourth) generates all 12
tones and in an order which puts notes in the same key next to each other, and it is the most
basic of the integer ratios -- other than the octave -- at 3:2

the only other interval to generate all 12 tones is the semitone (= -majSeventh), though
you'd have no idea what notes are in the same key given the list in semitone order

proof of this is that 5, 7, and 11 are the only numbers which are both less than and relatively
prime to 12, and they correspond to the intervals of fourth, fifth, and major seventh respectively.
from group theory we know generators of Z/n are relatively prime to n


--}
differencesInTuning :: [(Note.T, Float)]
differencesInTuning =
    let getDiff (note, f1) (_note, f2) = (note, Frequency.centsDifference f1 f2)
    in
        zipWith getDiff frequenciesFromFifths frequenciesFromSemitones

